;;; -*- lexical-binding: t -*-
;;; Author: 2024-12-05 22:45:23
;;; Time-stamp: <2024-12-05 22:45:23 (ywatanabe)>
;;; File: ./self-evolving-agent/src/semacs-lang2elisp.el


(require 'semacs-config)
(require 'semacs-prompts)
(require 'semacs-utils)
(require 'semacs-version-control)
(require 'semacs-server)
(require 'semacs-logging)


;; ;; working
;; (defun semacs-to-full-prompt (prompt)
;;   (condition-case err
;;       (let* ((template (semacs-get-prompt "lang2elisp" "authorities" "logging" "notes"))
;;              (log-content (semacs--get-log)))
;;         (when template
;;           (let ((prompt-with-template (replace-regexp-in-string "PLACEHOLDER" prompt template t t)))
;;             (if log-content
;;                 (concat prompt-with-template "\n\n" log-content)
;;               prompt-with-template))))
;;     (error
;;      (semacs--log-error (format "Failed to create full prompt.\nError: %s\nPrompt: %s"
;;                            (error-message-string err) prompt))
;;      nil)))

;; detailed error handling?
(defun semacs-to-full-prompt (prompt)
  (condition-case err
      (let* ((template (condition-case err1
                          (semacs-get-prompt "lang2elisp" "authorities" "logging" "notes")
                        (error
                         (semacs--log-error (format "Template fetch failed: %s" (error-message-string err1)))
                         nil)))
             (log-content (condition-case err2
                             (semacs--get-log)
                           (error
                            (semacs--log-error (format "Log fetch failed: %s" (error-message-string err2)))
                            nil))))
        (when template
          (condition-case err3
              (let ((prompt-with-template (replace-regexp-in-string "PLACEHOLDER" prompt template t t)))
                (if log-content
                    (concat prompt-with-template "\n\n" log-content)
                  prompt-with-template))
            (error
             (semacs--log-error (format "Template substitution failed: %s" (error-message-string err3)))
             nil))))
    (error
     (semacs--log-error (format "Full prompt creation failed: %s" (error-message-string err)))
     nil)))

 ;; "authorities" "logging" "notes"
;; (semacs-to-full-prompt "Hello")


(defun semacs-prompt2response (prompt)
  (interactive)
  (condition-case err
      (let* ((full-prompt (semacs-to-full-prompt prompt))
             (response (request
                       "https://api.anthropic.com/v1/messages"
                       :type "POST"
                       :headers `(("content-type" . "application/json")
                                ("x-api-key" . ,semacs-anthropic-key)
                                ("anthropic-version" . "2023-06-01"))
                       :data (json-encode
                             `(("model" . ,semacs-anthropic-engine)
                               ("max_tokens" . 8192)
                               ("messages" . [,(list (cons "role" "user")
                                                   (cons "content" full-prompt))])))
                       :parser 'json-read
                       :sync t
                       :silent t))
             (resp-data (request-response-data response)))
        (when resp-data
          (alist-get 'text (aref (alist-get 'content resp-data) 0))))
    (error
     (semacs--log-error (format "API request failed.\nError: %s\nPrompt: %s"
                           (error-message-string err) prompt))
     nil)))
;; (semacs-prompt2response "hello world")
;; returns:
;; "```json
;; {
;; \"commands\": [
;; {
;; \"function\": \"message\",
;; \"args\": [\"Hello, world!\"]
;; }
;; ]
;; }
;; ```"

(defun semacs--json-elisp-commands-to-elisp (json-data)
  (condition-case err
      (if (not (alist-get 'commands json-data))
          (error "No 'commands' field in JSON data: %s" json-data)
        (let* ((commands (alist-get 'commands json-data))
               (progn-form
                (cons 'progn
                      (mapcar
                       (lambda (cmd)
                         (unless (and (alist-get 'function cmd)
                                    (alist-get 'args cmd))
                           (error "Invalid command format: missing function or args in command: %s" cmd))
                         (let ((fn (alist-get 'function cmd))
                               (args (append (alist-get 'args cmd) nil)))
                           (cons (intern fn) args)))
                       commands))))
          progn-form))
    (error
     (semacs--log-error
      (format "JSON to Elisp conversion failed.\nError: %s\nInput JSON: %s"
              (error-message-string err)
              json-data))
     nil)))

;; (defun semacs--prompt-to-elisp (prompt)
;;   (interactive)
;;   (let ((response-text nil))
;;     (condition-case err
;;         (progn
;;           (setq response-text (semacs-prompt2response prompt))
;;           (let* ((json-str-clean (replace-regexp-in-string "```json\\|```" "" response-text))
;;                  (json-data (json-read-from-string json-str-clean)))
;;             (semacs--json-elisp-commands-to-elisp json-data)))
;;       (error
;;        (semacs--log-error
;;         (format "Failed to convert prompt to elisp.\nError: %s\nPrompt: %s\nResponse: %s"
;;                 (error-message-string err) prompt response-text))
;;        nil))))





(defun semacs--extract-json-blocks (text)
  "Extract all JSON blocks between ```json and ``` markers from TEXT."
  (let ((blocks nil)
        (start 0))
    (while (string-match "```json\n\\(\\(?:.\\|\n\\)*?\\)\n```" text start)
      (push (string-trim (match-string 1 text)) blocks)
      (setq start (match-end 0)))
    (if blocks
        (nreverse blocks)
      (error "No JSON blocks found in response"))))

(defun test-json-extraction ()
  (with-temp-buffer
    (insert-file-contents "/tmp/jsonfile.json")
    (let ((content (buffer-string)))
      (semacs--extract-json-blocks content))))

; (test-json-extraction)


(defun semacs--prompt-to-elisp (prompt)
  (interactive)
  (let ((response-text nil)
        (json-blocks nil)
        (commands nil))
    (condition-case err
        (setq response-text (semacs-prompt2response prompt))
      (error
       (semacs--log-error
        (format "API request failed.\nError: %s\nPrompt: %s"
                (error-message-string err) prompt))
       (signal 'semacs-api-error err)))

    (when response-text
      (condition-case err
          (setq json-blocks (semacs--extract-json-blocks response-text))
        (error
         (semacs--log-error
          (format "JSON extraction failed.\nError: %s\nResponse: %s"
                  (error-message-string err) response-text))
         (signal 'semacs-json-cleanup-error err)))

      (condition-case err
          (setq commands
                (mapcar (lambda (block)
                         (let ((json-data (json-read-from-string block)))
                           (semacs--json-elisp-commands-to-elisp json-data)))
                       json-blocks))
        (error
         (semacs--log-error
          (format "JSON parsing/conversion failed.\nError: %s\nBlocks: %s"
                  (error-message-string err) json-blocks))
         (signal 'semacs-json-parse-error err)))

      (cons 'progn commands))))

(provide 'semacs-lang2elisp)

(message "%s was loaded." (file-name-nondirectory (or load-file-name buffer-file-name)))
